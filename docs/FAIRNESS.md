# Provably Fair System Documentation

## Overview

CasinoBit uses a **Stake-style provably fair system** that allows players to verify the fairness of every bet. This system ensures that neither the casino nor the player can manipulate the outcome of any game.

## Core Concepts

### 1. Server Seed
- Generated by the server using cryptographically secure random number generation
- Kept secret until the seed pair is rotated
- Hashed (SHA-256) and shown to the player before betting

### 2. Client Seed
- Provided by the player or auto-generated
- Can be changed at any time (triggers seed rotation)
- Visible to both player and server

### 3. Nonce
- Starts at 0 for each seed pair
- Increments by 1 after each bet
- Ensures unique results for each bet

### 4. Cursor
- Used to generate unlimited random bytes
- Increments when more bytes are needed
- Allows for complex game outcomes

## How It Works

### Step 1: Seed Pair Creation

When a player registers or rotates seeds:

```typescript
// Server generates a new seed
const serverSeed = crypto.randomBytes(32).toString('hex');

// Hash it for the player to see
const serverSeedHash = crypto
  .createHash('sha256')
  .update(serverSeed)
  .digest('hex');

// Player provides or auto-generates client seed
const clientSeed = playerInput || crypto.randomBytes(16).toString('hex');

// Store seed pair with nonce = 0
const seedPair = {
  serverSeed,      // Secret
  serverSeedHash,  // Public
  clientSeed,      // Public
  nonce: 0,        // Public
  isActive: true,
  revealed: false
};
```

### Step 2: Placing a Bet

When a player places a bet:

```typescript
// Get active seed pair
const seedPair = getActiveSeedPair(userId);

// Generate random bytes using HMAC-SHA256
const message = `${seedPair.clientSeed}:${seedPair.nonce}:${cursor}`;
const hmac = crypto
  .createHmac('sha256', seedPair.serverSeed)
  .update(message)
  .digest('hex');

// Convert to bytes
const bytes = Buffer.from(hmac, 'hex');

// Generate float (0-1)
const float = bytes.readUInt32BE(0) / 0x100000000;

// Map to game outcome
const result = mapToGameEvent(float);

// Increment nonce for next bet
seedPair.nonce++;
```

### Step 3: Verification

After rotating seeds, players can verify past bets:

```typescript
// Server seed is now revealed
const revealedServerSeed = seedPair.serverSeed;

// Player can verify the hash
const calculatedHash = crypto
  .createHash('sha256')
  .update(revealedServerSeed)
  .digest('hex');

// Should match the original hash
assert(calculatedHash === seedPair.serverSeedHash);

// Recalculate each bet
for (const bet of bets) {
  const message = `${bet.clientSeed}:${bet.nonce}:0`;
  const hmac = crypto
    .createHmac('sha256', revealedServerSeed)
    .update(message)
    .digest('hex');
  
  const bytes = Buffer.from(hmac, 'hex');
  const float = bytes.readUInt32BE(0) / 0x100000000;
  const result = mapToGameEvent(float);
  
  // Verify result matches
  assert(result === bet.result);
}
```

## Game-Specific Implementations

### Dice

```typescript
// Generate roll (0-100 with 2 decimals)
const float = generateFloat(seedData);
const roll = parseFloat((float * 100).toFixed(2));

// Check win
const won = isOver ? roll > target : roll < target;
```

### Limbo

```typescript
// Generate multiplier using exponential distribution
const float = generateFloat(seedData);
const houseEdgeMultiplier = (100 - houseEdge) / 100;
const result = ((99 * houseEdgeMultiplier) / (100 * float)).toFixed(2);
```

### Mines

```typescript
// Create grid with mines
const tiles = Array(gridSize).fill(false);
for (let i = 0; i < minesCount; i++) {
  tiles[i] = true;
}

// Shuffle using Fisher-Yates with provably fair RNG
const floats = generateFloats(seedData, gridSize);
for (let i = tiles.length - 1; i > 0; i--) {
  const j = Math.floor(floats[tiles.length - 1 - i] * (i + 1));
  [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
}
```

### Plinko

```typescript
// Generate path (left=0, right=1)
const floats = generateFloats(seedData, rows);
const path = floats.map(f => (f < 0.5 ? 0 : 1));

// Calculate final slot
const finalSlot = path.reduce((sum, dir) => sum + dir, 0);

// Get multiplier from table
const multiplier = multiplierTable[risk][rows][finalSlot];
```

### Crash (Multiplayer)

```typescript
// Generate crash point for round
const float = generateFloat({
  serverSeed: roundServerSeed,
  clientSeed: roundClientSeed,
  nonce: roundNumber,
});

const houseEdge = 0.01;
const crashPoint = (99 * (1 - houseEdge)) / (100 * float);
```

### Roulette

```typescript
// Generate winning number (0-36)
const float = generateFloat(seedData);
const winningNumber = Math.floor(float * 37);
```

### Keno

```typescript
// Generate 10 drawn numbers from 1-40
const allNumbers = Array.from({ length: 40 }, (_, i) => i + 1);
const shuffled = shuffle(allNumbers, seedData);
const drawnNumbers = shuffled.slice(0, 10);
```

## Byte Generator

The core of the system is the byte generator:

```typescript
function byteGenerator(seedData: SeedData, count: number): Buffer {
  const { serverSeed, clientSeed, nonce } = seedData;
  let cursor = seedData.cursor || 0;
  const bytes: number[] = [];

  while (bytes.length < count) {
    // Generate HMAC for current cursor
    const message = `${clientSeed}:${nonce}:${cursor}`;
    const hmac = crypto
      .createHmac('sha256', serverSeed)
      .update(message)
      .digest('hex');
    
    const hmacBytes = Buffer.from(hmac, 'hex');
    
    // Add bytes to result
    for (let i = 0; i < hmacBytes.length && bytes.length < count; i++) {
      bytes.push(hmacBytes[i]);
    }
    
    cursor++;
  }

  return Buffer.from(bytes);
}
```

## Float Generation

Converting bytes to floats (0-1):

```typescript
function generateFloats(seedData: SeedData, count: number): number[] {
  const bytesNeeded = count * 4; // 4 bytes per float
  const bytes = byteGenerator(seedData, bytesNeeded);
  const floats: number[] = [];

  for (let i = 0; i < count; i++) {
    const offset = i * 4;
    const value = bytes.readUInt32BE(offset);
    floats.push(value / 0x100000000); // Divide by 2^32
  }

  return floats;
}
```

## Fisher-Yates Shuffle

For card games and grid-based games:

```typescript
function shuffle<T>(array: T[], seedData: SeedData): T[] {
  const result = [...array];
  const floats = generateFloats(seedData, result.length);

  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(floats[result.length - 1 - i] * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }

  return result;
}
```

## Verification Process

### Manual Verification

Players can manually verify bets:

1. **Get Bet Data**
   - Server seed (after rotation)
   - Client seed
   - Nonce
   - Game result

2. **Verify Server Seed Hash**
   ```javascript
   const hash = CryptoJS.SHA256(serverSeed).toString();
   console.log(hash === serverSeedHash); // Should be true
   ```

3. **Recalculate Result**
   ```javascript
   const message = `${clientSeed}:${nonce}:0`;
   const hmac = CryptoJS.HmacSHA256(message, serverSeed).toString();
   const bytes = hexToBytes(hmac);
   const float = bytesToFloat(bytes);
   const result = mapToGameEvent(float);
   ```

### Using the Verifier Page

The platform provides a verifier page where players can:

1. Enter bet ID or seed pair data
2. View the calculation breakdown
3. See step-by-step verification
4. Compare with actual result

## Security Guarantees

### For Players

1. **Pre-commitment**: Server seed hash is shown before betting
2. **Transparency**: All inputs (client seed, nonce) are visible
3. **Verifiability**: Can verify any bet after seed rotation
4. **Control**: Can change client seed anytime

### For Casino

1. **Unpredictability**: Player cannot predict server seed
2. **Integrity**: Player cannot manipulate outcome
3. **Fairness**: House edge is mathematically guaranteed

## Best Practices

### For Players

1. **Change Client Seed**: Regularly change your client seed
2. **Verify Bets**: Periodically verify past bets
3. **Rotate Seeds**: Rotate seed pairs to reveal server seed
4. **Keep Records**: Save seed pair data for verification

### For Operators

1. **Secure Generation**: Use cryptographically secure RNG
2. **Proper Storage**: Store server seeds securely
3. **Clear Documentation**: Provide clear verification guides
4. **Audit Trail**: Maintain complete bet history

## Common Questions

### Q: Can the casino cheat?

No. The server seed is committed (hashed) before you bet. The casino cannot change it after seeing your bet.

### Q: Can I cheat?

No. You cannot predict the server seed from its hash. Even if you know the client seed and nonce, you cannot determine the outcome without the server seed.

### Q: Why use HMAC instead of just hashing?

HMAC provides better security properties and is the industry standard for provably fair systems.

### Q: What if I lose my seed data?

All seed pairs and bets are stored on the server. You can always retrieve them from your account history.

### Q: How often should I rotate seeds?

It's recommended to rotate seeds every 100-1000 bets, or whenever you want to verify past bets.

## Technical Specifications

- **Hash Algorithm**: SHA-256
- **HMAC Algorithm**: HMAC-SHA256
- **Server Seed Length**: 64 characters (32 bytes hex)
- **Client Seed Length**: 32 characters (16 bytes hex)
- **Float Precision**: 32-bit (4 bytes per float)
- **Maximum Nonce**: 2^32 - 1

## References

- [Stake.com Provably Fair](https://stake.com/provably-fair)
- [HMAC-SHA256 Specification](https://tools.ietf.org/html/rfc2104)
- [Cryptographic Hash Functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
- [Fisher-Yates Shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)

## Conclusion

The provably fair system ensures complete transparency and fairness in all games. Players can verify every bet, and the casino cannot manipulate outcomes. This builds trust and provides a superior gaming experience.
